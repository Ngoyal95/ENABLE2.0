#! python3
'''
Functions related to JSON serialization, uploading to database backend, and pulling from database backend
'''
#7/18/17
import time
import json
import copy
import datetime
import BLDataClasses
import traceback
from bson import json_util
from pprint import pprint
from pymongo import MongoClient
from pymongo.errors import ConnectionFailure

def patient_uploader_func(StudyRoot,patient,multi):
    '''
    Function takes in StudyRoot, calls json_serialize function, and then uploads all patients in the StudyRoot who are not set to patient.ignore == True.
    'multi' == True indicates that entire StudyRoot should be uploaded. Otherwise will upload only the provided patient.
    '''
    patients = json_serialize(StudyRoot)
    if multi == True:
        for pt in patients:
            push_to_mongodb(dict(pt))
    else:
        push_to_mongodb(dict(patient))
    
def json_serialize(StudyRoot):
    '''
    Function to serialize patient objects in preparation for upload to MongoDB database.
    Returns list of patient dictionaries which are JSON compliant.
    '''
    localroot = copy.deepcopy(StudyRoot) #need to copy to prevent modifying original StudyRoot
    patientList = []

    for k1, patient in localroot.patients.items():
        if patient.ignore == False:
            patientDict = vars(patient)
            for k2,exam in patient.exams.items():
                newLesionList = []
                for lesion in exam.lesions:
                    newLesionList.append(vars(lesion))
                num = exam.exam_num #use to insert into correct dict location in patient.exams
                patientDict['exams'][num] = vars(exam)
                patientDict['exams'][num]['lesions'] = newLesionList
                #patientDict['uploaded_by'] = 
            pushVal = json.loads(json.dumps(patientDict, default=json_util.default,sort_keys=True, indent=4,allow_nan = True))
            pushVal['upload_timestamp_utc'] = datetime.datetime.utcnow() #wont serialize properly if added before. Now remains as proper ISO object
            patientList.append(pushVal)

    return patientList

def push_to_mongodb(serialized):
    '''
    Function to submit serialied patient data to the database.
    Argument is expected to be a single dict corresponding to a patient.
    '''

    client = MongoClient() # connect to localhost on port 27017
    # try:
    #     # The ismaster command is cheap and does not require auth.
    #     client.admin.command('ismaster')
    # except ConnectionFailure:
    #     print("Server not available")

    db = client.test # access the 'test' db
    result = db.patients.insert_one(serialized)
    client.close()

def pull_patient_list_from_mongodb():
    '''
    Queries MongoDB database to collect list of patient names and corresponding MRN/study protocol.
    Pull data from the most recent patient upload (the date is embedded into the autogenerated MongoDB "_id" field).
    '''

    client = MongoClient()
    db = client.test


    patient_list = db.patients.distinct("name")
    mrn_list = []
    protocol_list = []
    db_id_list = []

    for name in patient_list:
        try:
            cursor = db.patients.find({"name":name})
            cursor.sort("upload_timestamp_utc",-1) #sort, most recently entered exam come first
            pt = cursor[0] #get the most recently entered exam
            mrn_list.append(pt['mrn'])
            protocol_list.append(pt['study_protocol'])
            db_id_list.append(pt['_id'])
            cursor.close()
        except Exception as e:
            traceback.print_exc()
            print("Error: ", e)
  
    client.close()
    return (patient_list, mrn_list, protocol_list,db_id_list)

def pull_patients_from_mongodb(FetchRoot,fetch_list):
    '''
    Function retrieves the patients whose names appear in 'fetch_list', stores resulting patient objects into the FetchRoot.
    '''
    #using list of patients to fetch
    fetched = []
    client = MongoClient()
    db = client.test
    for pt in fetch_list:
        fetched.append(db.patients.find_one({"name":pt.split(' - ',1)[0]})) #Need to pass only names (ex. "Smith, John Bob")
    map_mongo_dict_to_ptobj(FetchRoot,fetched)
    client.close()

def map_mongo_dict_to_ptobj(FetchRoot,fetched):
    '''
    Map the dict returned from mongodb into a patient object compatible with ENABLE's code.
    Argument 'fetched' is a list of dictionaries. 
    Fetched patient objects are stored in a new root (the FetchRoot). No return value.
    '''

    for pt in fetched:
        patient = BLDataClasses.Patient(pt['mrn'], pt['study_protocol'], pt['name'], pt['bookmark_list_fields']) #initialize pt object
        ptkey = patient.mrn + r'/' + patient.study_protocol

        for pt_param_key in pt.keys():
            if pt_param_key != 'exams' and pt_param_key != '_id' and pt_param_key != 'upload_timestamp':
                setattr(patient, pt_param_key, pt[pt_param_key])
        
        for examkey in pt['exams'].keys():
            exam = BLDataClasses.Exam(pt['exams'][examkey]['exam_num'], pt['exams'][examkey]['study_instance_uid'])
            for exam_param_key in pt['exams'][examkey].keys():
                if exam_param_key != 'lesions':
                    setattr(exam, exam_param_key, pt['exams'][examkey][exam_param_key])
            for lesionobj in pt['exams'][examkey]['lesions']:
                lesion = BLDataClasses.Lesion()
                lesion.add_newlesion(lesionobj['newlesion'])
                lesion.params = lesionobj['params'] 
                exam.add_lesion(lesion)
            patient.add_exam({int(examkey):exam}) #exam key is a str unless casted to int (unsure why)
        
        FetchRoot.add_patient({ptkey:patient})

#### Test Code ####
def test_pull_patients_from_mongodb(FetchRoot,fetch_list):
    '''
    Function retrieves the patients whose names appear in 'fetch_list', stores resulting patient objects into the FetchRoot.
    '''
    #using list of patients to fetch
    fetched = []
    client = MongoClient()
    db = client.test
    for pt in fetch_list:
        fetched.append(db.patients.find_one({"name":pt})) #Need to pass only names (ex. "Smith, John Bob")
    test_map_mongo_dict_to_ptobj(FetchRoot,fetched)
    client.close()
    
def test_pull_patient_list_from_mongodb():
    '''
    Queries MongoDB database to collect list of patient names and corresponding MRN/study protocol.
    Pull data from the most recent patient upload (the date is embedded into the autogenerated MongoDB "_id" field).
    '''

    client = MongoClient()
    db = client.test


    patient_list = db.patients.distinct("name")
    mrn_list = []
    protocol_list = []
    db_id_list = []

    for name in patient_list:
        try:
            cursor = db.patients.find({"name":name})
            cursor.sort("upload_timestamp_utc",-1) #sort, most recently entered exam come first
            pt = cursor[0] #get the most recently entered exam
            mrn_list.append(pt['mrn'])
            protocol_list.append(pt['study_protocol'])
            db_id_list.append(pt['_id'])
            cursor.close()
        except Exception as e:
            traceback.print_exc()
            print("Error: ", e)
  
    client.close()
    return patient_list

def test_map_mongo_dict_to_ptobj(FetchRoot,fetched):
    '''
    Map the dict returned from mongodb into a patient object compatible with ENABLE's code.
    Argument 'fetched' is a list of dictionaries. 
    Fetched patient objects are stored in a new root (the FetchRoot). No return value.
    '''
    counter = 0
    for pt in fetched:
        patient = BLDataClasses.Patient(pt['mrn'], pt['study_protocol'], pt['name'], pt['bookmark_list_fields']) #initialize pt object
        ptkey = patient.mrn + r'/' + patient.study_protocol

        for pt_param_key in pt.keys():
            if pt_param_key != 'exams' and pt_param_key != '_id' and pt_param_key != 'upload_timestamp':
                
                if pt[pt_param_key] is not None:
                    counter += 1 ###
                
                setattr(patient, pt_param_key, pt[pt_param_key])
        
        for examkey in pt['exams'].keys():
            exam = BLDataClasses.Exam(pt['exams'][examkey]['exam_num'], pt['exams'][examkey]['study_instance_uid'])
            for exam_param_key in pt['exams'][examkey].keys():
                if exam_param_key != 'lesions':
                    
                    if pt['exams'][examkey][exam_param_key] is not None:
                        counter += 1 ###
                    
                    setattr(exam, exam_param_key, pt['exams'][examkey][exam_param_key])
            for lesionobj in pt['exams'][examkey]['lesions']:
                lesion = BLDataClasses.Lesion()
                lesion.add_newlesion(lesionobj['newlesion'])
                lesion.params = lesionobj['params'] 
                exam.add_lesion(lesion)

                if lesion.params['Target'] != 'Unspecified':
                    counter += sum(x is not None for x in lesionobj['params'])

            patient.add_exam({int(examkey):exam}) #exam key is a str unless casted to int (unsure why)
        
        FetchRoot.add_patient({ptkey:patient})
        print(counter)

if __name__ == '__main__':
    #testing code
    start_time = time.clock()
    FetchRoot = BLDataClasses.StudyRoot()
    test_pull_patients_from_mongodb(FetchRoot,test_pull_patient_list_from_mongodb())
    print("Fetch took --- %s seconds ---" % (time.clock() - start_time))