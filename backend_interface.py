#! python3
'''
Functions related to JSON serialization, uploading to database backend, and pulling from database backend
'''
#7/18/17
import time
import json
import copy
import datetime
import BLDataClasses
from bson import json_util
from pprint import pprint
from dbInterface import testFnx
from pymongo import MongoClient
from pymongo.errors import ConnectionFailure


def patient_uploader_func(StudyRoot):
    '''
    Function takes in StudyRoot, calls json_serialize function, and then uploads all patients in the StudyRoot who are not set to patient.ignore == True.
    '''
    patients = json_serialize(StudyRoot)
    for patient in patients:
        push_to_mongodb(dict(patient))
    
def json_serialize(StudyRoot):
    '''
    Function to serialize patient objects in preparation for upload to MongoDB database.
    Returns list of patient dictionaries which are JSON compliant.
    '''
    localroot = copy.deepcopy(StudyRoot) #need to copy to prevent modifying original StudyRoot
    patientList = []

    for k1, patient in localroot.patients.items():
        if patient.ignore == False:
            patientDict = vars(patient)
            for k2,exam in patient.exams.items():
                newLesionList = []
                for lesion in exam.lesions:
                    newLesionList.append(vars(lesion))
                num = exam.exam_num #use to insert into correct dict location in patient.exams
                patientDict['exams'][num] = vars(exam)
                patientDict['exams'][num]['lesions'] = newLesionList
                patientDict['upload_timestamp'] = str(datetime.datetime.now())
               #patientDict['uploaded_by'] = usr
            pushVal = json.loads(json.dumps(patientDict, default=json_util.default,sort_keys=True, indent=4,allow_nan = True))
            patientList.append(pushVal)

    return patientList

def push_to_mongodb(serialized):
    '''
    Function to submit serialied patient data to the database.
    Argument is expected to be a single dict corresponding to a patient.
    '''

    client = MongoClient() # connect to localhost on port 27017
    # try:
    #     # The ismaster command is cheap and does not require auth.
    #     client.admin.command('ismaster')
    # except ConnectionFailure:
    #     print("Server not available")

    db = client.test # access the 'test' db
    result = db.patients.insert_one(serialized)
    client.close()

def pull_patient_list_from_mongodb():
    '''
    Queries MongoDB database to collect list of patient names and corresponding MRN/study protocol.
    Pull data from the most recent patient upload (the date is embedded into the autogenerated MongoDB "_id" field).
    '''
    client = MongoClient()
    db = client.test
    patient_list = db.patients.distinct("name")
    mrn_list = db.patients.distinct("mrn")
    protocol_list = db.patients.distinct("study_protocol")
    client.close()
    return patient_list #list of strings (patient names)


def pull_patients_from_mongodb(FetchRoot,fetch_list):
    '''
    Function retrieves the patients whose names appear in 'fetch_list', stores resulting patient objects into the FetchRoot.
    '''
    #fetched = db.patients.find_one({"name":stored_patient_list[0]}) #returns a dict
    
    #using list of patients to fetch
    fetched = []
    client = MongoClient()
    db = client.test
    for pt in fetch_list:
        fetched.append(db.patients.find_one({"name":pt}))

    map_mongo_dict_to_ptobj(FetchRoot,fetched)
    client.close()

def map_mongo_dict_to_ptobj(FetchRoot,fetched):
    '''
    Map the dict returned from mongodb into a patient object compatible with ENABLE's code.
    Argument 'fetched' is a list of dictionaries. 
    Fetched patient objects are stored in a new root (the FetchRoot). No return value.
    '''
    #counter = 0

    for pt in fetched:
        patient = BLDataClasses.Patient(pt['mrn'], pt['study_protocol'], pt['name'], pt['bookmark_list_fields']) #initialize pt object
        ptkey = patient.mrn + r'/' + patient.study_protocol

        for pt_param_key in pt.keys():
            if pt_param_key != 'exams' and pt_param_key != '_id' and pt_param_key != 'upload_timestamp':
                #counter += 1
                setattr(patient, pt_param_key, pt[pt_param_key])
        
        for examkey in pt['exams'].keys():
            exam = BLDataClasses.Exam(pt['exams'][examkey]['exam_num'], pt['exams'][examkey]['study_instance_uid'])
            for exam_param_key in pt['exams'][examkey].keys():
                if exam_param_key != 'lesions':
                    #counter += 1
                    setattr(exam, exam_param_key, pt['exams'][examkey][exam_param_key])
                for lesionobj in pt['exams'][examkey]['lesions']:
                    # if lesionobj['params']['Target'].lower() != 'unspecified':
                    #     #counter += len(lesionobj)
                    exam.add_lesion(lesionobj)
            patient.add_exam({examkey:exam})
        FetchRoot.add_patient({ptkey:patient})
    
    #print(counter)
    # pprint(FetchRoot)
    # pprint(FetchRoot.patients)
    # for key, patient in FetchRoot.patients.items():
    #     pprint(vars(patient))
    #print(FetchRoot.patients.keys())

if __name__ == '__main__':
    #testing code
    start_time = time.clock()
    FetchRoot = BLDataClasses.StudyRoot()
    pull_patients_from_mongodb(FetchRoot,pull_patient_list_from_mongodb())
    print("Fetch took --- %s seconds ---" % (time.clock() - start_time))